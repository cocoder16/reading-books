# 3장. 함수

- 조건문이나 루프 중첩 구조가 생길만큼 함수가 커져서는 안된다
- 단일 책임 원칙 지키기
  - 오류 처리도 한 가지 작업이다.
- try/catch 블록은 별도의 함수로 뽑아내기
  - try/catch 블록은 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다.
- 함수당 추상화 수준은 하나로(동일한 수준으로) 유지하기 (함수 내 모든 문장의 추상화 수준은 동일해야 한다)
  - 높은 추상화 수준 예시) getHtml()
  - 중간 추상화 수준 예시) String pagePathName = PathParser.render(pagepath);
  - 낮은 추상화 수준 예시) .append("\n")
  - 함수 내 추상화 수준이 섞이면 특정 표현이 근본 개념인지 세부사항인지 구분하기 어려워진다.<br />
  게다가 이것은 [깨진 창문](https://github.com/cocoder16/reading-books/blob/master/ThePragmaticProgrammer/topic03.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%97%94%ED%8A%B8%EB%A1%9C%ED%94%BC.md)과 같아 사람들이 함수에 섞인 추상화 수준을 계속 추가하게 된다.
- **내려가기 규칙** 지키기
- 인수: 이상적인 인수 개수는 0개이다. 다음은 1개, 다음은 2개이다. 3개는 가능한 피하는 편이 좋다. 4개 이상은 특별한 이유가 필요하다. 특별한 이유가 있어도 사용하면 안 된다.
- 부수효과(사이드이팩트)를 일으키지 말기
  - 부수효과는 단일책임원칙을 위배한다.
  - 부수효과는 시간적 결합(temporal coupling)이나 순서 종속성(order  dependency)를 초래한다. 

## 내려가기 규칙

한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.<br />
즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.

## switch 문

switch문은 작게 만들기 어렵다. 또한 switch문은 본질적으로 N가지을 처리한다. <br />
switch문을 완전히 피할 방법은 없다.

switch문을 잘쓰는 방법은 각 switch문을 저차원 클래스에 숨기고 절대로 반복하지 않는 것이다.

일반적으로 switch문은 다형적 객체를 생성하는 코드 안에서 단 한번 참아준다.
