# DDD : Domain-Driven Design (에릭 에반스)

## 이 책의 접근법을 사용하기 위한 선행 조건

1. 개발은 반복주기를 토대로 진행돼야 한다. (애자일)
2. 개발자와 도메인 전문가는 밀접한 관계에 있어야 한다.

## DDD의 목표

1. 기술보다는 도메인에 대한 모델에 집중해 더 나은 소프트웨어를 만들어내는 것

## 효과적인 모델링의 요소

1. 모델과 구현의 연계

초기 프로토타입을 토대로 본질적인 연결 고리를 만든 다음, 이어지는 모든 반복 주기 내내 그 연결고리를 유지한다.

2. 모델을 기반으로 하는 언어 정제

누구라도 모델에서 바로 용어를 끄집어내어 모델의 구조와 일관되게 문장을 구성할 수 있게 됐고 별도의 해석 없이도 문장을 명확히 이해할 수 있다.

3. 풍부한 지식이 담긴 모델 개발

객체는 행위를 지니고 규칙을 이행한다. 모델은 단순한 데이터 스키마가 아니라 복잡한 문제를 해결하는 데 필수불가결한 것이다. 그리고 모델에는 다양한 지식이 포함돼 있다.

4. 모델의 정제

불필요하거나 중요하지 않은 개념은 모델에서 제거되고, 본질적인 개념만을 식별할 수 있는 모델을 고안한다.

5. 브레인스토밍과 실험

수백 가지의 실험용 변종을 연습하고 시도하며 평가한다.

## Ubiquitous language (보편 언어)

- 모델에서는 도메인 전문가, 개발자 모두가 이해할 수 있는 보편 언어를 사용해야 한다.
- 모델을 언어의 근간으로 사용해야 한다. 팀 내 모든 의사소통과 코드에서 해덩 언어를 사용한다.
- 모델의 취약점은 부자연스러운 용어를 찾을 것이고, 부자연스러운 용어는 수정된다.<br />
  그리고 유비쿼터스 랭귀지의 변화는 곧 모델의 변화다.
- 언어가 변경되면 새 언어에 맞게끔 클래스, 메서드, 모듈의 이름을 다시 지으면서 코드를 리팩터링해야한다.

## Layered Architecture (계층형 아키텍처)

**(상위 계층) UI : 응용 : 도메인 : 인프라스트럭처 (하위 계층)**

---

1. 사용자 인터페이스 (표현 계층)

사용자에게 정보를 보여주고 사용자의 명령을 해석하는 일을 책임진다.

2. 응용 계층

소프트웨어가 수행할 작업을 정의하고 표현력 있는 도메인 객체가 문제를 해결하게 한다. <br />
이 계층에서 책임지는 작업은 업무상 중요하거나 다른 시스템의 응용 계층과 상호작용 하는 데 필요한 것들이다. <br />
이 계층은 얇게 유지된다. 여기에는 업무 규칙이나 지식이 포함되지 않으며, 오직 작업을 조정하고 아래에 위치한 계층에 포함된 도메인 객체의 협력자에게 작업을 위임한다. <br />
응용 계층에서는 업무 상황을 반영하는 상태가 없지만 사용자나 프로그램의 작업에 대한 진행상황을 반영하는 상태를 가질 수는 있다.

3. 도메인 계층

업무 개념과 업무 상황에 관한 정보, 업무 규칙을 표현하는 일을 책임진다. 이 계층에서는 업무 상황을 반영하는 상태를 제어하고 사용하며, 그와 같은 상태 저장과 관련된 기술적인 세부사항은 인프라스트럭처에 위임한다. 이 계층은 업무용 소프트웨어의 핵심이다.

4. 인프라스트럭처 계층

상위 계층을 지원하는 일반화도니 기술적 기능을 제공한다. 또한 인프라스트럭처 계층은 아키텍처 프레임워크를 통해 네 가지 계층에 대한 상호작용 패턴을 지원할 수도 있다.

---

- 도메인에 관련된 코드가 상당한 양의 도메인과 관련이 없는 다른 코드를 통해 널리 확산될 경우 도메인에 관련된 코드를 확인하고 추론하기가 굉장히 힘들어진다.<br />
  도메인 계층은 모델이 살아가는 곳이다. DDD의 전제 조건은 도메인 구현을 다른 관심사와 분리하는 것이다.

- 응용 계층이 아닌 **도메인 계층에서 업무 규칙을 책임**진다.

- Model Driven Design을 가능케 하는 것은 결정적으로 도메인 계층을 분리하는 데 있다.

- 각 게층은 설계 의존성을 오직 한 방향으로만 둬서 느슨하게 결합된다. 상위 계층은 하위 게층의 공개 인터페이스를 호출하고 하위 계층에 대한 참조를 가진다.

## DDD와 절대 서로 양립할 수 없는 Smart UI

Smart UI: 모든 업무 로직을 UI에 넣는다

## Service

자신의 본거지를 Entity나 Value Object에서 찾지 못하는 중요한 도메인 연산이 있다.

"오늘날 흔히 하는 실수는 행위를 적절한 객체로 다듬는 것을 너무나도 쉽게 포기해서 절차적 프로그래밍에 빠지는 것이다. 하지만 객체의 정의에 어울리지 않는 연산을 강제로 객체에 포함시킨다면 해당 객체는 자신의 개념적 명확성을 잃어버리고 이해하거나 리팩터링하기 힘들어질 것이다."

"도메인의 개념 가운데 객체로는 모델에 어울리지 않는 것이 있다. 필요한 도메인 긴으을 Entity나 Value에서 억지로 맡게 하면 모델에 기반을 둔 객체의 정의가 왜곡되거나, 또는 무의미하고 인위적으로 만들어진 객체가 추가될 것이다."

service는 모델에서 독립적인 인터페이스로 제공되는 연산으로서 entity나 value object와는 달리 상태를 캡슐화하지 않는다.

service의 3가지 특징

1. 연산이 원래부터 entity나 value object의 일부를 구성하는 것이 아니라 도메인 개념과 관련돼 있다.
2. 인터페이스가 도메인 모델의 외적 요소의 측면에서 정의된다.
3. 연산이 상태를 갖지 않는다.

도메인의 중대한 프로세스나 변환 과정이 entity나 value object의 고유한 책임이 아니라면 연산을 service로 선언되는 독립 인터페이스로 모델에 추가해야한다. <br />
service는 상태를 갖지 않게 만들어야한다.

service는 도메인 계층에서만 이용되는 것이 아니다. 도메인 계층에 속하는 service와 다른 계층에 속하는 service를 구분한다.

## 도메인 객체의 생명주기

도메인 객체의 관리와 관련된 문제

1. 생명주기 동안의 무결성 유지하기
2. 생명주기 관리의 복잡성으로 모델이 난해해지는 것을 방지하기

해결법: Aggregate(집합체), Factory, Repository

Aggreate를 모델링하고 설계에 Factory와 Repository를 추가하면 모델 객체의 생명주기 동안 그것들을 체계적이고 의미 있는 단위로 조작할 수 있다.

### Aggregate

- 우리가 데이터 변경의 단위로 다루는 연관 객체의 묶음을 말한다.
- Aggregate에는 루트(root)와 경계(boundary)가 있다.
- 경계는 Aggregate에 포함되는 것과 포함되지 않는 것을 정의한다.
- 루트는 단 하나만 존재하며, Aggregate에 포함된 특정 Entity를 가리킨다.
- 경계 안의 객체는 서로 참조할 수 있지만, 경계 바깥의 객체는 해당 Aggregate의 구성요소 가운데 루트만 참조할 수 있다. <br />
  루트가 아닌 Entity는 지역 식별성을 지니며, 지역 식별성은 Aggregate 내에서만 구분되면 된다.

### 개념적 Aggregate를 구현하기 위해 모든 트랜잭션에 적용되는 규칙

- 루트 Entity는 전역 식별성을 지니며 궁극적으로 불변식을 검사할 책임이 있다.
- 각 루트 entity는 전역 식별성을 지닌다. 경계 안의 Entity는 지역 식별성을 지니며, 이러한 지역 식별성은 해당 Aggregate 안에서만 유일하다.
- Aggregate의 경계 밖에서는 루트 Entity를 제외한 Aggregate 내부의 구성요소를 참조할 수 없다. 루트 Entity가 내부 Entity에 대한 참조를 다른 객체에 전달해 줄 수는 있지만 그러한 객체는 전달받은 참조를 일시적으로만 사용할 수 있고, 참조를 계속 보유하고 있을 수는 없다. 루트는 Value Object의 복사본을 다른 객체에 전달해 줄 수 있으며, 복사본에서는 어떤 일이 일어나든 문제되지 않는다. 이것은 복사본이 단순한 Value에 불과하며 Aggregate와는 더는 연관관계를 맺지 않을 것이기 때문이다.
- 지금까지의 규칙을 바탕으로 결론을 내려보면 데이터베이스 질의를 이용하면 Aggregate의 루트만 직접적으로 획득할 수 있다. 다른 객체는 모두 Aggregate를 탐색해서 발견해야 한다.
- Aggregate 안의 객체는 다른 Aggregate의 루트만 참조할 수 있다.
- 삭제 연산 Aggregate 경계 안의 모든 요소를 한 번에 제거해야 한다. (가비지 컬렉션을 이용하면 이렇게 하기가 쉬운데, 루트를 제외한 나머지 구성요소는 외부에서 그것을 참조하지 않을 경우 루트가 삭제되면 가비지 컬렉터가 자동으로 그것들을 모두 수집할 것이기 때문이다.)
- Aggregate 경계 안의 어떤 객체를 변경하더라도 전체 Aggregate의 불변식은 모두 지켜져야 한다.

(구매주문의 무결성 예제 - p134)

### Factory

- 복잡한 객체와 Aggregate의 인스턴스를 생성하는 책임을 별도의 객체로 옮겨야 한다.<br />이 객체 자체는 도메인 모델에서 아무런 책임도 맡지 않을 수도 있지만 여전히 도메인 설계의 일부를 구성한다.
- 모든 복잡한 객체 조립 과정을 캡슐화하는 동시에 클라이언트가 인스턴스화 되는 객체의 구상 클래스를 참조할 필요가 없는 인스턴스를 제공해야 한다.
- 전체 Aggregate를 하나의 단위로 생성해서 그것의 불변식이 이행되게 해야한다.
- Factory를 설계하는 방법들: Factory method, Abstract factory, Builder

## 리팩터링

유용한 모델을 개발하기 위해서 해당 도메인을 학습하는 개발자와 도메인 전문가의 긴밀한 참여와 반복적인 리팩터링 과정이 있어야한다.

### 명세 (Specification)

어떤 객체가 특정 기준을 만족하는지 판단하는 술어

- 생성기의 구현을 인터페이스로부터 분리(decouple)할 수 있다.
- 개발자들이 연산의 세부적인 사항을 이해하지 않고도 결과물을 예상할 수 있다.<br />
  절차적인 방식으로 정의된 생성기의 경우 어떻게 작동할지 예상하려면 여러 가지 경우를 직접 실행해 보거나 코드를 한줄한줄 읽어보고 이해하는 수밖에 없다.
- 생성기는 단순히 Specification에 포함된 조건에 따라 객체를 생성하는 반면 생성 요청을 표현하는 코드는 클라이언트에 존재하므로 더 유연한 인터페이스를 얻거나 더 유연하게 개선할 수 있다.
- 이런 종류의 인터페이스는 생성기에 대한 입력을 정의하는 명시적인 방법이 모델에 포함돼 있어서 테스트하기 더 수월하다.

### 유연한 설계

1. Intention-revealing interface (의도를 드러내는 인터페이스)

- 개발자가 컴포넌트를 사용하기 위해 컴포넌트의 구현 세부사항을 고려해야 한다면 캡슐화의 가치는 사라진다.

- 해당 도메인 내에 존재하는 개념을 클래스나 메서드의 형태로 명확하게 모델링해서 가치를 얻으려면 해당 도메인 개념을 반영하도록 클래스와 메서드의 이름을 지어야 한다.

> 네이밍 방법
>
> - 수행 방법에 관해서는 언급하지 말고 결과와 목적만을 표현하도록 클래스와 연산의 이름을 부여하라. <br />
>   이렇게 하면 클라이언트 개발자가 내부를 이해해야 할 필요성이 줄어든다.
> - Ubiquitous language에 포함된 용어를 따라야 한다.
> - 클라이언트 개발자의 관점에서 생각하기 위해 클래스와 연산을 추가하기 전에 행위에 대한 테스트를 먼저 작성하라.

2. Side-effect-free function (부수효과가 없는 함수)

- 가능한 한 많은 양의 프로그램 로직을 관찰 가능한 부수효과 없이 결과를 반환하는 함수 안에 작성하라.

3. Assertion (단언)

- 자동화된 단위 테스트를 작성해서 assertion의 내용을 표현하라.
- 개발자들이 의도된 assertion을 추측할 수 있게 인도하고, 쉽게 배울 수 있고 모순된 코드를 작성하는 위험을 줄이는 응집도 높은 개념이 포함된 모델을 만드려고 노력하라.

**1~3종합)** Side-effect-free function과 assertion의 예측 가능성을 intension-revealing interface의 의사전달력과 결합하면 더 안전한 캡슐화와 추상화가 가능해진다.

4. Conceptual contour (개념적 윤곽)

- 도메인을 중요 영역을 나누는 것과 관련한 직관을 감안해서 설계 요소(연산, 인터페이스, 클래스, Aggregate)를 응집력 있는 단위로 분해하라.
- 계속적인 리팩터링을 토대로 변경되는 부분과 변경되지 않는 부분을 나누는 중심 축을 식별하고, 변경을 분리하기 위한 패턴을 명확하게 표현하는 conceptual contour를 찾아라.

**1~4종합)** Intention-revealing interface는 클라이언트가 단순 메커니즘이 아닌 의미 단위로 객체를 제공하게 해준다. Side-effect-free function과 Assertion은 그러한 단위를 사용해 복잡한 조합을 만드는 일을 안전하게 만든다. 이러한 Conceptual contour의 출현으로 모델의 각 부분은 안정화될뿐더러 각 단위는 직관적으로 사용하고 조합할 수 있게 된다.

5. Standalone class (독립형 클래스)

- Module 내에서조차 의존성이 증가할수록 설계를 파악하는 데 따르는 어려움이 가파르게 높아진다.
- 낮은 결합도는 객체 설계의 기본 원리이다.
- 가능한 결합도를 낮추고, 현재 상황과 무관한 모든 개념을 제거하라. 그러면 클래스가 완전히 독립적으로 바뀌고 단독으로 검토하고 이해할 수 있게 된다. 그러한 독립적인 클래스는 module을 이해하는 데 따르는 부담을 상당히 덜어준다.

6. Closure of operation (연산의 닫힘)

닫힘 개념 기본 예시) 덧셈 연산은 실수 집합에 대해 닫혀 있다.

- 적절한 위치에 반환 타입과 인자 타입이 동일한 연산을 정의하라.
- 구현자(implementer)가 연산에 사용되는 형태를 포함하고 있다면 연산의 인자로 구현자를 사용하는 것이 효과적이므로 인자의 타입과 반환 타입을 구현자의 타입과 동일하게 정의한다. 이런 방식으로 정의된 연산은 해당 타입의 인스턴스 집합에 닫혀 있다.
- 닫힌 연산은 부차적인개념을 사용하지 않고도 고수준의 인터페이스를 제공한다.

### 리팩터링 타이밍

- 현대 팀에서 도메인을 이해하고 있는 바가 설계에 표현돼 있지 않은 경우
- 중요한 개념이 설계상에 암시적으로 표현돼 있는 경우(그리고 개념을 명확하게 표현할 수 있는 방법이 보이는 경우)
- 설계상의 중요한 부분을 더욱 유연하게 만들 기회가 보이는 경우

## 모델의 무결성 유지

### Bounded context (제한된 컨텍스트)

다수의 모델이 사용될 때, 종종 어떤 컨텍스트에서 어떤 모델을 사용해서는 안되는지 불분명한 경우가 있다.

- 모델이 적용되는 컨텍스트를 팀 조직, 애플리케이션의 특정 부분에서의 사용법, 코드 기반이나 데이터베이스 스키마와 같은 물리적인 형태의 관점에서 명시적으로 정의해야 한다.
- 이 경계 내에서는 모델을 엄격하게 일관된 상태로 유지하고 경계 바깥의 이슈 때문에초점이 흐려지거나 혼란스러워져서는 안 된다.

### Continuous Integration (지속적 통합)

- 통합을 위한 효과적인 프로세스의 특징

1. 단계적이고 재생 가능한 병합/빌드 기법
2. 자동화된 테스트 스위트
3. 수정사항이 통합되지 않은 상태로 존재할 수 있는 시간을 적당히 짧게 유지하는 규칙

- CI는 오직 하나의 Bounded context 내에서만 필수적이다.

### Context map (컨텍스트 맵)

각 컨텍스트의 현재 영역을 나타내는 지도, 각 컨텍스트들은 모델들을 포함 (맵 그림 p 370)

- context경계에서의 테스트: 다른 Bounded context와 접촉하는 지점은 테스트할 때 특히 중요하다.

### Shared kernel (공유 터널)

- CI를 하기 힘든 환경일 때, 두 팀 간에 공유하기로 한 도메인 모델의 부분집합을 컨텍스트 맵에서 공유 영역으로 명시.
- 기능 시스템을 자주 통합하고, 통합할 때에는 양 팀에서 작성한 테스트를 모두 실행

### Customer/Supplier Development team (고객/공급자 개발 팀)

- 상류 하위 시스템과 하류 하위 시스템은 자연스럽게 두 개의 Bounded context로 나뉜다. (하류 팀은 상류 팀에서 제공하는 것을 필요로 한다.)
- 자동화된 인수 테스트(acceptance test)를 함께 개발해야 한다.
- 이 테스트를 상류 팀의 테스트 스위트에 추가해서 지속적인 통합의 일부로 실행되게 해야 한다. <br />
  이러한 테스트를 토대로 상류 팀은 하류 시스템에서 발생할지도 모르는 부수효과를 두려워하지 않고 자유로이 코드를 변경할 수 있다.

### Conformist (준수자)

상류/하류 관계에 있는 두 팀이 효과적으로 같은 조직의 지시를 받지 않아, Customer/Supplier team과 같은 협력 패턴이 원활하게 작용하지 않을 때 대책

### Anticorruption layer (오류 방지 계층)

클라이언트 고유의 도메인 모델 측면에서 기능을 제공할 수 있는 격리 계층을 만들어야 한다. 격리 계층은 기존에 이미 존재하는 인터페이스를 거쳐 다른 시스템과 통신하므로 다른 시스템을 거의 수정하지 않아도 된다.

- 구현

여러 시스템 간의 상호작용에 필요한 통신 및 전송 메커니즘과 Facade, Adapter, 번역기를 조합하는 방법

### Separate ways (각자의 길)

- 통합의 비용이 혜택보다 더 큰 경우 통합을 포기
- Bounded context가 다른 것과 아무런 관계도 맺지 않도록 선언

### Open host service (공개 호스트 서비스)

### Published language (공표된 언어)

두 Bounded context의 모델 간에 이뤄지는 번역에는 공통의 언어가 필요하다.

## context 병합

1. Separate ways -> Shared kernel
2. Shared kernel -> Continuous integration

## 디스틸레이션(distillation)

혼합된 요소를 분리해서 본질을 좀더 값지고 유용한 형태로 뽑아내는 과정

### Core domain (핵심 도메인)

- Core domain을 찾아 그것을 지원하는 다수의 모델과 코드로부터 쉽게 구별할 수 있는 수단을 제공해야한다.
- 시간 제약상 두 가지 수행할 필요가 있는 리팩터링 가운데 어느 것을 해야 할지 결정할 때에는 Core domain에 가장 큰 영향을 줄 수 있는 것을 먼저 택해야 한다.
- 표시된 Core: 모델의 주요 저장소 안에 있는 Core domain의 고성요소에 대해 그것의 역할을 설명하려 하지 말고 표시해야 한다. 개발자가 힘들이지 않고도 Core의 안과 밖을 알 수 있도록 해야 한다.

### Generic subdomain (일반 하위 도메인)

- Core domain에 많은 노력을 기울이고 보조적인 성격의 generic subdomain에는 필요한 만큼만 투자한다.
- 일반화가 재사용 가능을 의미하는 것은 아니다.
- 재사용을 목표로 설계할 일은 거의 없더라도 일반 개념의 범위 내에서 설계를 유지하는 것과 관련해서는 엄격해야 한다.

### Cohesive mechanism (응집력 있는 메커니즘)

- Generic subdomain과 마찬가지로 Core domain의 부담을 더는 데 목적이 있다.
- Cohesive mechanism은 도메인을 나타내지 않는다.
- Core domain에서 불분명한 함수를 호출하기보다 의미있는 진술을 하고, Cohesive mechanism은 Core domain에서 맡기 성가신 계산 문제를 해결해준다.
- 모델이 제안하면 Cohesive mechanism은 처리한다.
- Assertion, Side-effect-free function을 지니고, intention-revealing interface를 통해 접근할 수 있을 때 가장 유용하다.

### Abstract core (추상화된 핵심)

- 모델의 가장 근본적인 개념을 식별해서 그것을 별도의 클래스나 추상 클래스, 또는 인터페이스로 추출해야한다.
- 이 추상 모델이 중요 컴포넌트 간에 발생하는 상호작용을 대부분 표현할 수 있게끔 설계해야한다.
- Abstract code는 결국 디스틸레이션 문서와 아주 비슷해보일 것이고, 코드로 작성되므로 더 엄격하고 완전할 것이다.

### 리팩터링

1. 문제의 근원에 Core domain이나, Core와 지원 요소와의 관계가 관련돼 있는지 살핀다. 만약 그렇다면, 그 부분을 가장 먼저 고쳐야 한다.
2. 마음껏 리팩터링할 수 있는 상황이라면 제일 먼저 Core domain을 더 잘 분해하고, Core의 격리를 개선하며, 보조적인 하위 도메인이 Generic하게 만드는 데 집중한다.
