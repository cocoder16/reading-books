
# topic 9. DRY: 중복의 해악

## DRY 원칙

모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현되어야 한다.

## DRY 원칙 위반

### 코드의 중복

중복 코드는 함수로 리팩토링

### 지식의 중복

```
def validate_age(value):
  validate_type(value, :integer)
  validate_min_integer(value, 1)

def validate_quantity(value):
  validate_type(value, :integer)
  validate_min_integer(value, 1)
```

두함수는 코드는 중복되지만, 두 함수가 표현하는 지식은 다르다. <br />
서로 validate하고 있는 대상이 다르기 때문이다. 이 둘은 현재 우연히 규칙이 같아 같은 코드를 사용하는 것일 뿐이다.

### 의도의 중복

함수에 주석달지말자. <br />
함수에 주석을 달면 함수의 의도는 주석으로 한번, 코드로 한번, 총 두번 표현된다. <br />
만약 요구사항이 바뀌어 함수의 의도를 바꿔야 하면 두 군데를 함꼐 고쳐야 한다. <br />
시간이 지남에 따라 주석과 코드의 내용이 서로 어긋나게 될 거라고 거의 확실히 장담할 수 있다.

### 데이터의 DRY 위반

자료구조는 지식을 표현한다. 그리고 DRY 원칙을 위배할 수 있다.

```
# DRY 원칙을 위배한 자료구조 클래스 예시

class Line {
  Point start;
  Point end;
  double length;
}
```

start, end만 알면 length 를 구할 수 있으므로 DRY 원칙 위배다. <br />
하지만 성능상의 이유로 연산을 여러 번 수행 하지 않기 위해 고의로 DRY 원칙을 위배할 수 있다. <br />
이떄 요령은, 바깥 세상에는 DRY 원칙 위배를 노출하지 않고, 클래스 내의 private 메소드로 객체의 속성을 읽고 쓰도록 한다. <br />

### 표현상의 중복

코드를 바깥세상과 연결할 때, 연결을 표현하는 지식을 우리의 코드와 외부의 존재 양쪽이 모두 알아야 하기 때문에 중복이 생긴다. <br />
한쪽에서만 바꾸면 다른 쪽은 망가질 것이다. <br />
이런 중복을 불가피하지만, 관리포인트를 줄이는 전략을 취할 수는 있다.

- 내부 API에서 생기는 중복: 언어나 기술에 중립적인 형식으로 내부 API를 정의할 수 있는 도구
- 외부 API에서 생기는 중복: 공개 API를 OpenAPI 같은 형식으로 문서화할 때, API 도구로 불러와서 API명세를 사용하기

### 데이터 저장소와의 중복

데이터 스키마분석 기능으로 데이터 저장소와 코드간의 중복제거: 데이터를 객체로 옮기기 위한 코드를 손으로 만드는 것이 아니라 스키마로부터 바로 생성하는 것. <br />
이것을 하는 프레임워크를 사용
