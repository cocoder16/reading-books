# topic 39. 알고리즘의 속도

## 상식으로 추정하기

빠른 순서

1. O(1)
2. 반씩 자르기: O(log n)
3. 단순 반복문: O(n)
4. 분할 정복(divide and conquer): O(n log n)
5. 중첩 반복문: O(n^2)
6. O(2^n)
7. 조합적(combinatoric): O(n!)

## 알고리즘 문제 해결을 위한 사고

- 사용하는 알고리즘의 차수를 추정하고 차수를 개선하기

예를 들어, O(n^2) 알고리즘이 있다면 분할 정복을 사용하여 O(n log n)으로 줄일 수 없는지 생각하기

- 입력값 n이 작은 경우는, 단순한 O(n^2) 코드가 복잡한 O(n log n) 코드보다 더 좋은 성능을 내기도 한다. <br />
O(n log n) 코드 반복문 안에 무거운 작업이 있으면 더욱 그렇다.

- 추정을 이미 했다고 하더라도 실제 서비스에서 실제 데이터로 돌아가는 수행 시간만이 의미 있는 수치이다.
  - 즉, 추정을 테스트 해봐라.
  - 수 많은 레코드를 입력하면 스래싱(thrashing)이 발생하면서 갑자기 수행 시간이 폭증하기도 한다.
  - 정확하게 시간을 재는 일이 어렵다면 코드 프로파일러를 사용하여 알고리즘이 돌아갈 때 각 단계의 실행횟수를 센 다음 입력값 크기별 실행 횟수를 그래프로 그려 보라.

- 성급한 최적화를 조심하라
