# 리팩터링

## Chapter 01. 리팩터링: 첫 번째 예시

- 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 머저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.
- 리팩터링의 첫 단계는 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드들부터 마련해야 한다.
- 하나의 리팩터링을 문제없이 끝낼 때마다 커밋한다. 자잘한 변경들이 어느 정도 의미 있는 단위로 뭉쳐지면 공유 저장소로 푸시한다.
- 때로는 리팩터링이 성능에 상당한 영향을 줄 때도 있다. 그런 경우라도 개의치 않고 리팩터링한다. 잘 다듬어진 코드라야 성능 개선 작업도 훨씬 수월하기 때문이다.
  - 리팩터링 때문에 성능이 떨어진다면, 하던 리팩터링을 마무리하고 나서 성능을 개선하자.
- 좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.

## Chapter 02. 리팩터링 원칙

**기회가 될 때만 진행하는 리팩터링**

1. 기능을 새로 추가하기 직전
2. 코드 수정을 위해 기존 코드를 이해할 때
3. 코드 파악 중에 비효율적인 코드를 발견할 때

**리팩터링하지 말아야 할 때**

1. 지저분한 코드를 발견해도 굳이 수정할 필요가 없을 때 (외부 API 다루듯 호출해서 쓰는 코드는 내부 동작을 이해해야할 시점에 리팩터링)
2. 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때

**리팩터링의 본질**

리팩터링은 코드 베이스를 예쁘게 꾸미는 목적이 아니라, 오로지 경제적인 이유로 하는 것이다.

리팩터링은 개발 기간을 단축하고자 하는 것이다. 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다.

**지속적 통합**

기능별 브랜치들이 독립적으로 개발되는 기간이 길어질수록 머지 복잡성은 기하급수적으로 늘어난다.<br />
CI에 따르면 하루에 최소 한 번은 마스터와 통합한다.

**리팩터링이 아키텍처에 미치는 실질적인 효과**

간결한 설계, 점진적 설계, YAGNI(you aren't going to need it)

진화형 아키텍처 원칙: 나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 훨씬 낫다<br/>
진화형 아키텍처는 아키텍처 관련 결정을 시간을 두고 반복해 내릴 수 있다는 장점을 활용하는 패턴과 실천법을 추구한다

**성능 개선**

대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다.<br />
따라서 코드 전체를 고르게 최적화한다면 그중 90%는 효과가 거의 없기 때문에 시간낭비인 셈이다.

즉, 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는 데 집중한다.

단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수도 있다.<br />
하지만 최적화 단계에서 코드를 튜닝하기 훨씬 쉬워지기 때문에 결국 더 빠른 소프트웨어를 얻게 된다.

## Chapter 06. 기본적인 리팩터링

- 함수 추출하기
  - 반대 리팩터링: 함수 인라인하기
    - 대상: 잘못 추출된 함수, 간접 호출을 너무 과하게 쓰는 코드
- 변수 추출하기
  - 반대 리팩터링: 변수 인라인하기
    - 대상: 그 이름이 원래 표현식과 다를 바 없을 때, 변수가 주변 코드를 리팩터링하는 데 방해가 될 때
- 함수 선언 바꾸기 (함수명 바꾸기, 매개변수 추가하기, 매개변수를 속성으로 바꾸기)
- 변수 캡슐화하기
- 변수 이름 바꾸기
- 매개변수 객체 만들기
  - 대상: 데이터 항목 여러 개가 이 함수에서 저 함수로 함꼐 몰려다니는 경우
- 여러 함수를 클래스로 묶기
  - 대상: 원본 데이터가 코드 안에서 갱신될 때에는 클래스로 묶는다
- 여러 함수를 변환 함수로 묶기
  - 변환 함수: 원본 데이터를 입력받아서 필요한 정보를 모두 도출한 뒤, 각각을 출력 데이터의 필드에 넣어 반환한다.
  - 대상: 가공한 새 데이터를 새로운 레코드에 저장할 때에는 변환함수를 사용한다.
- 단계 쪼개기
  - 대상: 서로 다른 두 대상을 한꺼번에 다루는 코드를 별개 모듈로 나누기

## Chapter 07. 캡슐화

- 레코드 캡슐화하기
- 컬렉션 캡슐화하기
  - 깊은 복사 사용하기
- 기본형을 객체로 바꾸기
  - 대상: 단순한 출력 이상의 기능이 필요해지는 순간 그 데이터를 표현하는 전용 클래스를 정의
- 임시 변수를 질의 함수로 바꾸기
  - 임시 변수: 어떤 코드의 결과값을 뒤에서 다시 참조할 목적으로 만든 변수
  - 임시 변수를 질의 함수로 바꾸면, 부자연스러운 의존 관계나 부수효과를 찾고 제거하는 데 도움이 된다.
  - 임시 변수를 질의 함수로 바꾼다고 무조건 다 좋아지는 건 아니다. 자고로 변수는 값을 한 번만 계산하고, 그 뒤로는 읽기만 해야 한다.
  - 클래스 안에서 적용할 때 효과가 가장 크다
- 클래스 추출하기
  - 반대 리팩터링: 클래스 인라인하기
    - 대상: 특정 클래스에 남은 역할이 거의 없을 때
- 위임 숨기기
  - 반대 리팩터링: 중개자 제거하기

## Chapter 08. 기능 이동

- 함수 옮기기
- 필드 옮기기
- 문장을 함수로 옮기기
  - 중복제거
  - 반대 리팩터링: 문장을 호출한 곳으로 옮기기
    - 대상: 여러 곳에서 사용하던 기능이 일부 호출자에게는 다르게 동작하도록 바뀌어야 할 때
- 인라인 코드를 함수 호출로 바꾸기
  - 대상: 이미 존재하는 함수와 똑같은 일을 하는 인라인 코드
  - 예외: 순전히 우연히 비슷한 코드가 만들어졌을 뿐, 기존 함수의 코드를 수정하더라도 인라인 코드의 동작은 바뀌지 않아야 할 때
- 문장 슬라이드하기
  - 하나의 데이터 구조를 이용하는 문장들은 한데 모여 있어야 좋다.
    - 예를 들면, 모든 변수 선언을 함수 첫머리에 모아두는 것 보다 변수를 처음 사용할 때 선언하는 스타일이 좋다.
  - 부수효과가 없는 코드끼리는 마음 가는 대로 재배치할 수 있다. (부수효과가 없는 코드들로 프로그래밍하기)
- 반복문 쪼개기
  - 대상: 그저 동시에 처리할 수 있다는 이유로 반복문 하나에서 여러 일을 수행하는 경우
  - 각각의 반복문으로 분리해두면 수정할 동작 하나만 이해하면 된다.
  - 한 가지 값만 계산하는 반복문이라면 그 값만 곧바로 반환할 수 있다. 반면 여러 일을 수행하면 구조체를 반환하거나 지역 변수를 활용해야 한다.
  - 반복문 쪼개기는 서로 다른 일을 한 함수에서 하고 있다는 신호일 수 있다. 따라서 함수 추출하기를 연이어 수행하는 경우가 잦다.
- 반복문을 파이프라인으로 바꾸기
```
// ex
const names = input.filter(i => i.job === "programmer").map(i => i.name);
```
- 죽은 코드 제거하기

## Chapter 09. 데이터 조직화

- 변수 쪼개기
  - 대입이 두번 이상 이뤄진다면 여러 역할을 수행한다는 신호다. 역할 하나당 변수 하나다.
- 필드 이름 바꾸기
- 파생 변수를 질의 함수로 바꾸기
- 참조를 값으로 바꾸기
  - 반대 리팩터링: 값을 참조로 바꾸기
- 매직 리터럴 바꾸기
  - 숫자를 기호 상수로 전환  

## Chapter 10. 조건부 로직 간소화

- 조건문 분해하기 (조건문 추상화)
- 조건식 통합하기
  - 대상: 조건은 다르지만 수행 동작이 같은 것들
- 중첩 조건문을 보호 구문으로 바꾸기
  - 조건문은 1) 참인 경로와 거짓인 경로 모두 정상 동작인 경우, 2) 한쪽만 정상인 경우로 나뉜다.
  - 2)의 경우 비정상 조건을 if에서 검사한 다음 비정상이면 함수에서 빠져나온다. 이를 보호 구문이라고 한다.
