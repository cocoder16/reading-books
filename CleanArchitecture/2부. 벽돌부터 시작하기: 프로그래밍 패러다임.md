# 3장. 패러다임 개요

1. 구조적 프로그래밍
2. 객체 지향 프로그래밍
3. 함수형 프로그래밍

패러다임은 우리에게 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.<br />
세 가지 패러다임은 각각 우리에게서 goto문, 함수 포인터, 할당문을 앗아간다. <br />

# 4장. 구조적 프로그래밍

goto대신 if/else/while/for 등을 사용

# 5장. 객체 지향 프로그래밍

**객체 지향이란 무엇인가?**

**흔한 답변**

- 실제 세계를 모델링하는 새로운 방법
- 캡슐화, 상속, 다형성을 사용한다

**소프트웨어 아키텍트 관점에서의 답변**

OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다. <br/>
OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고,<br/>
이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.<br/>
저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

## 의존성 역전

제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어흐름에 따라 결정된다.

하지만 다형성이 끼어들면 **의존성 역전**이 일어난다.

OO언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디서든 역전시킬 수 있다는 뜻이기도 하다.

호출하는 모듈이든 아니면 호출 받는 모듈이든 관계없이 소프트웨어 아키텍트는 소스 코드 의존성을 원하는 방향으로 설정할 수 있다.

### 의존성 역전으로 할 수 있는 것

- 컴포넌트들을 분리하여 독립적으로 배포할 수 있다. -> 배포 독립성
- 모듈을 독립적으로 배포할 수 있게 되면, 각 모듈을 독립적으로 개발할 수 있다. -> 개발 독립성

# 6장. 함수형 프로그래밍

함수형 언어에서 변수는 변경되지 않는다.

## 불변성과 아키텍처

변수의 불변성을 지키는 이유:

경합(race)조건, 교착(deadlock)조건, 동시 업데이트 문제가 모두 가변 변수로 인해 발생하기 때문이다.

## 가변성의 분리

**불변 컴포넌트N:가변 컴포넌트1:트랜잭션 메모리1** (그림6.1)

불변 컴포넌트

- 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.
- 불변 컴포넌트는 순수 함수형 컴포넌트가 아닌, 변수의 상태를 변경할 수 있는 하나 이상의 다른 컴포넌트와 서로 통신한다.

트랜잭션 메모리

- 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호한다.
- 트랜잭션 메모리는 데이터베이스가 디스크의 레코드를 다루는 방식과 동일한 방식으로 메모리의 변수를 처리한다.

이렇게 분리하려면 가변변수들을 보호하는 적절한 수단을 동원해 뒷받침해야한다.

가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.

## 이벤트 소싱

- 상태가 아닌 트랜잭션을 저장하자는 전략이다.
- 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.
- 이 전략에서는 가변 변수가 하나도 필요 없다.
- 데이터 저장소에서는 삭제되거나 변경되는 것이 하나도 없다.
- 결과적으로 애플리케이션은 CRUD가 아니라 그저 CR만 수행한다.
- UD가 전혀 없으므로, 동시 업데이트 문제 또한 일어나지 않는다.
- 저장 공간과 처리 능력이 충분하다면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고, 완전한 함수형으로 만들 수 있다.
- 소스 코드 버전 관리 시스템이 정확히 이 방식으로 동작한다.

# 결론

- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.

소프트웨어는 순차, 분기, 반복, 참조로 구성된다. 그 이상도 이하도 아니다.
