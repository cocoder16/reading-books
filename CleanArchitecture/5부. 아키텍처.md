# 5부. 아키텍처

# 15장. 아키텍처란?

좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.

정책은 세부 사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다.

## 선택 사항 열어 두기

- 개발 초기에는 데이터베이스 시스템을 선택할 필요가 없다. 고수준의 정책은 어떤 종류의 데이터베이스를 사용하는지 신경 써서는 안된다.
- 개발 초기에는 웹 서버를 선택할 필요가 없다.
- 개발 초기에는 REST를 적용할 필요가 없다.
- 개발 초기에는 의존성 주입 프레임워크를 적용할 필요가 없다.

# 16장. 독립성

좋은 아키텍처가 지원해야하는 것들

- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포 (즉각적인 배포)

## 결합 분리 모드

- 소스 수준 분리 모드 (ex) 루비 Gem
- 배포 수준 분리 모드
- 서비스 수준 분리 모드 (ex) 서비스 or 마이크로 서비스

**서비스 수준 분리 모드 문제점**

- 비용이 많이 들고, 결합이 큰 단위에서 분리된다.
- 개발 시간 측면뿐 아니라 시스템 자원 측면에서도 비용이 많이 든다

좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장하고,<br />
또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 한다.<br />
또한 나중에 상황이 바뀌었을때 이 진행 방향을 거꾸로 돌려 원래 형태인 모노리틱 구조로 되돌릴 수도 있어야 한다.

# 19장. 정책과 수준

수준(level): 입력과 출력까지의 거리

시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다.<br />
입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치한다.

소스 코드 의존성은 그 수준에 따라 결합되어야 하며, 데이터 흐름을 기준으로 결합되어서는 안 된다

모든 소스 코드 의존성의 방향이 고수준 정책을 향할 수 있도록 정책을 분리했다면 변경의 영향도를 줄일 수 있다.<br />
시스템의 최저 수준에서 중요하지 않지만 긴급한 변경이 발생하더라도, 보다 높은 위치의 중요한 수준에 미치는 영향은 거의 없게 된다.

이 논의는 저수준 컴포넌트가 고수준 컴포넌트에 플러그인 되어야 한다는 관점으로 바라볼 수도 있다.

# 20장. 업무 규칙

**핵심 업무 규칙**

- 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차
- 소프트웨어 시스템이 존재하는 이유
- 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드

**핵심 업무 데이터**

- 핵심 업무 규칙이 요구하는 데이터

**엔티티**

- 핵심 규칙과 핵심 데이터는 본질적으로 결합되어 있기 때문에 객체로 만들 좋은 후보가 된다. 이런 유형의 객체를 엔티티라고 한다.

**유스케이스**

- 시스템이 사용자에게 어떻게 보이는지를 설명하지 않는다. (사용자 인터페이스를 기술하지 않는다.)
- 애플리케이션에 특화된 업무 규칙을 설명한다
- 사용자와 엔티티 사이의 상호작용을 규정한다
- 유스케이스는 객체다. 애플리케이션에 특화된 업무 규칙을 구현하는 하나 이상의 함수를 제공한다
- 엔티티는 자신을 제어하는 유스케이스에 대해 아무것도 알지 못한다 (의존성 역전 원칙)

# 21장. 소리치는 아키텍처

- 아키텍처는 프레임워크에 대한 것이 아니다.(절대 그래서도 안된다)
- 프레임워크는 사용하는 도구일 뿐, 아키텍처가 준수해야 할 대상이 아니다
- 아키텍처는 프레임워크가 아니라 유스케이스에 중점을 둬야 한다

# 22장. 클린 아키텍처

클린 아키텍처는 시스템이 다음과 같은 특징을 지니도록 만든다

- 프레임워크 독립성: 아키텍처는 프레임워크의 존재 여부에 의존하지 않는다. 프레임워크를 도구로 사용할 수 있다
- 테스트 용이성: 업무 규칙은 UI, 데이터베이스, 웹 서버 또는 여타 외부 요소가 없이도 테스트할 수 있다
- UI 독립성: 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다
- 데이터베이스 독립성: 업무 규칙은 데이터베이스에 결합되지 않는다
- 모든 외부 에이전시에 대한 독립성: 실제로 업무 규칙은 외부 세계와의 인터피에스에 대해 전혀 알지 못한다

## 의존성 규칙

**소스 코드의 의존성은 반드시 고수준의 정책을 향해야 한다.**

고수준의 정책에 해당하는 요소는 저수준의 정책에 해당하는 요소에 대해 어떤 것도 알지 못해야 한다

**고수준 -> 저수준**

엔티티(엔터프라이즈 업무 규칙) -> 유스케이스(애플리케이션 업무 규칙) -> 인터페이스 어댑터 -> 프레임워크와 드라이버

# 23장. 프레젠터와 험블 객체

**험블 객체 패턴**

테스트하기 어려운 행위와 테스트 하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.<br />
행위들을 두 개의 모듈 또는 클래스로 나눈다. 이들 중 하나가 험블이다. 가장 기본적인 본질은 남기고, 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다

각 아키텍처 경계마다 경계 가까이 숨어 있는 험블 객체 패턴을 발견할 수 있다.

**프레젠터와 뷰**

뷰는 험블 객체이고 테스트하기 어렵다. 프레젠터는 테스트하기 쉬운 객체다.

**데이터베이스 게이트웨이**

유스케이스 인터랙터와 데이터베이스 사이에는 데이터베이스 게이트웨이가 위치한다.<br />
유스케이스 계층은 SQL을 허용하지 않는다.<br />
유스케이스 계층은 필요한 메서드를 제공하는 게이트웨이 인터페이스를 호출한다. <br />
게이트웨이 인터페이스의 구현체는 험블 객체다. <br />
인터랙터는 험블 객체가 아니다. 따라서 테스트하기 쉽다. 이때 게이트웨이는 스텁이나 테스트 더블로 적당히 교체할 수 있다.

**데이터 매퍼**

ORM은 데이터베이스 계층이다.<br/>
ORM은 게이트웨이 인터페이스와 데이터베이스 사이에서 일종의 또 다른 험블 객체 경계를 형성한다.

# 26장. 메인 컴포넌트

모든 시스템에는 최소한 하나의 컴포넌트가 존재하고, 이 컴포넌트가 나머지 컴포넌트를 생성하고, 조정하며, 관리한다.<br />
이 컴포넌트를 메인이라고 부른다.

- 메인 컴포넌트는 궁극적인 세부사항으로, 가장 낮은 수준의 정책이다.
- 메인은 시스템의 초기 진입점이다.
- 메인은 가장 지저분한 저수준 모듈이다.
- 메인을 플러그인 컴포넌트로 여기고, 아키텍처 경계 바깥에 위치한다고 보면 설정 관련 문제를 훨씬 쉽게 해결할 수 있다.
