# TDD : Test Driven Development (켄트 벡)

## TDD 주기

1. 재빨리 테스트를 하나 추가한다.
2. 모든 테스트를 실행하고 새로 추가한 것이 실패하는지 확인한다.
3. 코드를 조금 바꾼다.
4. 모든 테스트를 실행하고 전부 성공하는지 확인한다.
5. 리팩토링을 통해 중복을 제거한다.

## TDD의 두 가지 법칙

1. 어떤 코드건 작성하기 전에 실패하는 자동화된 테스트를 작성하라.
2. 중복을 제거하라.

## 테스트와 코드 간의 문제

- 테스트와 코드 사이에 존재하는 의존성의 문제 :

코드나 테스트 중 한쪽을 수정하면 반드시 다른 한쪽도 수정해야만 한다는 것.

=> TDD의 두번째 법칙이 존재하는 이유 :
다음 테스트로 진행하기 전에 중복을 제거함으로써, 오직 한 가지의 코드 수정을 통해 다음 테스트도 통과되게 만들 가능성을 최대화하는 것이다.

## 아키텍처 주도 개발

우리 목적은 작동하는 깔끔한 코드를 얻는 것이다. <br />
하지만 이것은 어려운 일이다. <br />
그렇다면 나누어서 정복하자.

- '작동하는'을 먼저 해결하고 '깔끔한 코드'를 나중에 해결한다 => TDD
- 반면, '깔끔한 코드'를 먼저 해결하고, '작동하는'을 나중에 해결하는 것은 '아키텍처 주도 개발' 이다.
- TDD는 아키텍처 주도 개발과 정반대이다.

## 최대한 빨리 초록색을 보기 위해 취할 수 있는 전략

1. 가짜로 구현하기: 상수를 반환하게 만들고 진짜 코드를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 간다.
2. 명백한 구현 사용하기: 실제 구현을 입력한다.
3. 삼각측량 : 두 개 이상의 예제를 가지고 일반화된 코드를 구현한다.

평소에는 2번 모드로 하다가, 예상치 못한 빨간색을 만나면 한발 물러서서 1번 방법을 쓰면서 올바른 코드로 리팩토링해나간다. <br />
3번은 어떻게 리팩토링해야 하는지 전혀 감이 안 올 때 사용한다.

## 할 일 목록

할 일을 생각나는대로 그때 그때 목록에 추가한다. 아토믹한 단위의 할 일도 상관없다. <br />
할 일을 해치우면 선을 그어서 없앤다. <br />
할 일을 해치울 때마다 테스트 케이스가 추가되거나 테스트코드가 수정되거나, 실제 코드 구현을 하거나 리팩토링될 수 있다.

## 테스트 간의 의존성

테스트끼리는 서로 의존성이 없어야한다. 완전 독립적이어야 한다. <br />
(부적절한 경우 예시 - 테스트 A를 먼저 실행하고 테스트 B를 실행하면 성공하지만, 반대 순서로 하면 실패하는 경우) <br />
문제가 하나면 테스트도 반드시 하나만 실패해야 하고, <br />
문제가 둘이면 테스트도 반드시 두 개만 실패해야한다.

## 테스트 데이터

- 테스트를 읽을 때 쉽고 따라가기 좋을 만한 데이터를 사용하라.
- 데이터 값을 산발하지 마라. 예를 들어 1과 2사이에 어떠한 개념적 차이점도 없다면 1을 사용하라.

### 모의 객체

비용이 많이 들거나 복잡한 리소스에 의존하는 객체를 테스트하려면 상수를 반환하게끔 만든 속임수 버전의 리소스를 만들면 된다. => 모의 객체 (Mock Object) <br />
예를 들면 데이터베이스의 경우도 진짜를 사용하지 않고 모의 데이터베이스 객체를 만들어 사용한다.

- 모의 객체의 가치 : 성능, 견고함, 가독성

### 호출되지 않을 것 같은 에러 코드(발생하기 힘든 에러 상황)을 테스트 하는 방법

실제 작업을 수행하는 대신 그냥 예외를 발생시키기만 하는 특수한 객체를 만들어서 이를 호출한다.

## 깨진 테스트

1. 혼자서 프로그래밍할 때 프로그래밍 세션을 어떤 상태로 끝마치는 게 좋을까?

마지막 테스트가 깨진 상태로 끝마치는 것이 좋다. <br />
나중에 다시 코딩하기 위해 돌아왔을 때, 어느 작업부터 시작할 것인지 명백히 알 수 있고, 전에 하고 있던 생각에 대한 명확하고 구체적인 책갈피를 가지게 된다.

2. 반면, 팀 프로그래밍을 할 때에는 프로그래밍 세션을 어떤 상태로 끝마치는 게 좋을까?

모든 테스트가 성공한 상태로 끝마치는 것이 좋다. <br />
팀 프로젝트에서 프로그래밍 세션을 시작하는 경우라면 자신이 마지막으로 코딩한 다음부터 지금까지 무슨 일이 있었는지 세밀하게 알 수 없다. 안심되고 확신이 있는 상태에서 시작할 필요가 있다.

## 설계 문제가 있음을 알려주는 테스트의 속성들

1. 긴 셋업 코드: 하나의 단순한 단언을 수행하기 위해 수백 줄의 객체 생성 코드가 필요하다면 뭔가 문제가 있는 거다. 객체가 너무 크다는 뜻이므로 나눌 필요가 있다.

2. 셋업 중복: 공통의 셋업 코드를 넣어 둘 공통의 장소를 찾기 힘들다면, 서로 밀접하게 엉킨 객체들이 너무 많다는 뜻이다.

3. 실행 시간이 오래 걸리는 테스트: 실행하는 데 오래 걸리면 테스트를 자주 실행하지 않게 되고, 한동안 실행이 안된 채로 남게 되는 경우가 종종 있고, 이렇게 되면 테스트가 아예 동작하지 않을 수도 있다.

   > 이보다 더 나쁜 점은, 테스트의 실행 시간이 길다는 것이 애플리케이션의 작은 부분만 따로 테스트하기가 힘들다는 것을 의미한다는 것이다. 작은 부분만 테스트할 수 없다는 것은 설계 문제를 의미하고 설계를 적절히 변경해줄 필요가 있다.

4. 깨지기 쉬운 테스트: 예상치 못하게 실패하는 테스트가 있다면 이는 애플리케이션의 특정 부분이 다른 부분에 이상한 방법으로 영향을 끼친다는 뜻이다. 연결을 끊거나 두 부분을 합하는 것을 통해 멀리 떨어진 것의 영향력이 없어지도록 설계해야 한다.

## 철학 | 마인드

- 느낌(부작용에 대한)을 테스트로 변환하는 것은 TDD의 일반적인 주제다. <br />
  => 이걸 하면 설계 논의는 더 깊어진다. 시스템이 어떤 식으로 동작해야하는지 논의할 수 있다.
- TDD는 사람들이나 팀에게 강요할 수 없다. 개발습관, 방식이기 때문이다.
- 테스트를 통해 기능 설명을 요청하고 테스트를 통해 설명하라.
